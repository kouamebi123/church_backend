const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const compression = require('compression');
const path = require('path');
const http = require('http');
const { PrismaClient } = require('@prisma/client');
const { injectPrisma } = require('./config/dbPostgres');
const logger = require('./utils/logger');
const securityLogger = require('./utils/securityLogger');
const socketService = require('./services/socketService');
// Services optionnels - g√©rer l'absence de Redis
let redisService, metricsService;
try {
  redisService = require('./services/redisService');
  metricsService = require('./services/metricsService');
} catch (error) {
  // console.warn('Services optionnels non disponibles:', error.message);
  redisService = null;
  metricsService = null;
}
const {
  requestLogger,
  errorLogger,
  slowRequestLogger,
  unauthorizedAccessLogger,
  databaseLogger,
  authLogger,
  csrfLogger
} = require('./middlewares/requestLogger');
const prismaLogger = require('./middlewares/prismaLogger');
const csrfProtection = require('./middlewares/csrfProtection');
const securityHeaders = require('./middlewares/securityHeaders');
require('dotenv').config();

const app = express();
// Derri√®re un proxy/Load Balancer (X-Forwarded-For) pour un rate limit fiable
app.set('trust proxy', 1);
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL
    }
  },
  // Optimisation du pool de connexions pour haute charge
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  // Pool de connexions optimis√©
  __internal: {
    engine: {
      connectionLimit: 50, // Limite de connexions par worker
      pool: {
        min: 4,
        max: 30,
        acquireTimeoutMillis: 30000,
        createTimeoutMillis: 30000,
        destroyTimeoutMillis: 5000,
        idleTimeoutMillis: 30000,
        reapIntervalMillis: 1000,
        createRetryIntervalMillis: 200
      }
    }
  }
});

// Configuration CORS - DOIT √™tre avant helmet et rate limiting
const allowedOrigins = [
  'http://localhost:3000', // D√©veloppement direct
  'http://localhost', // Production via nginx
  'http://localhost:8080', // Port Swagger UI
  'https://multitudeszno.vercel.app',
  'https://church-production-9a34.up.railway.app', // Railway production
  'https://web-production-f5a55.up.railway.app' // Railway frontend
];

const corsOptions = {
  origin: function (origin, callback) {
    // Autoriser les requ√™tes sans origine (comme les apps mobiles ou Postman)
    if (!origin) return callback(null, true);

    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      console.log('CORS Error: Origin not allowed:', origin);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: [
    'Origin',
    'X-Requested-With',
    'Content-Type',
    'Accept',
    'Authorization',
    'Cache-Control',
    'X-CSRF-Token' // Ajout du header CSRF
  ],
  exposedHeaders: ['Content-Range', 'X-Content-Range', 'X-CSRF-Token'], // Exposer le header CSRF
  maxAge: 86400, // 24 heures
  preflightContinue: false,
  optionsSuccessStatus: 200
};

// Appliquer CORS AVANT tout autre middleware
app.use(cors(corsOptions));

// Gestion explicite des requ√™tes OPTIONS (preflight)
app.options('*', (req, res) => {
  const origin = req.headers.origin;
  if (allowedOrigins.includes(origin)) {
    res.header('Access-Control-Allow-Origin', origin);
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');
    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, Cache-Control, X-CSRF-Token');
    res.header('Access-Control-Allow-Credentials', 'true');
    res.header('Access-Control-Max-Age', '86400');
    res.status(200).end();
  } else {
    res.status(403).json({ error: 'Origin not allowed by CORS' });
  }
});


// Security middleware (apr√®s CORS)
app.use(helmet({
  crossOriginResourcePolicy: { policy: 'cross-origin' },
  contentSecurityPolicy: false // D√©sactiv√© car g√©r√© par securityHeaders
}));

// Headers de s√©curit√© ultra-stricts
app.use(securityHeaders);


// Middleware de protection supprim√©
app.use((req, res, next) => {
  return next();
});


// Rate limiting - Configuration √©quilibr√©e pour la s√©curit√© et l'usage normal
const limiter = rateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 200, // limite chaque IP √† 200 requ√™tes par minute (augment√© pour la messagerie)
  message: {
    success: false,
    message: 'üö´ Rate limit d√©pass√©: Trop de requ√™tes depuis cette IP'
  },
  standardHeaders: true,
  legacyHeaders: false,
  skipSuccessfulRequests: false,
  skipFailedRequests: false,
  handler: (req, res) => {
    // Logger la tentative d'attaque
    const context = securityLogger.enrichWithRequestContext(req);
    securityLogger.logRateLimitExceeded(context.ip, context.endpoint, context.method, req.rateLimit.current);

    res.status(429).json({
      success: false,
      message: 'üö´ Rate limit d√©pass√©: Trop de requ√™tes depuis cette IP',
      retryAfter: Math.ceil(req.rateLimit.resetTime / 1000)
    });
  }
});

// Rate limiting sp√©cial pour l'authentification (s√©curis√© mais utilisable)
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // Maximum 10 tentatives de connexion par 15 minutes
  message: {
    success: false,
    message: 'üö´ Trop de tentatives de connexion. R√©essayez dans 15 minutes.'
  },
  standardHeaders: true,
  legacyHeaders: false,
  skipSuccessfulRequests: true, // Ne pas compter les connexions r√©ussies
  skipFailedRequests: false,
  handler: (req, res) => {
    const context = securityLogger.enrichWithRequestContext(req);
    securityLogger.logUnauthorizedAccess(
      null, null, context.ip, context.endpoint, context.method,
      'Rate limit authentification d√©pass√©'
    );

    res.status(429).json({
      success: false,
      message: 'üö´ Trop de tentatives de connexion. R√©essayez dans 15 minutes.',
      retryAfter: Math.ceil(req.rateLimit.resetTime / 1000)
    });
  }
});

// Compression middleware (AVANT parsing pour optimiser)
app.use(compression({
  level: 6, // Niveau de compression √©quilibr√©
  threshold: 1024, // Compresser seulement si > 1KB
  filter: (req, res) => {
    if (req.headers['x-no-compression']) {
      return false;
    }
    return compression.filter(req, res);
  }
}));

// Parsing middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// === MIDDLEWARES DE LOGGING COMPLET ===
app.use(requestLogger);                    // Logging de toutes les requ√™tes/r√©ponses
app.use(slowRequestLogger(2000));         // D√©tection des requ√™tes lentes (>2s)
app.use(unauthorizedAccessLogger);        // Logging des acc√®s non autoris√©s
app.use(authLogger);                      // Logging des authentifications

// Timeout pour les requ√™tes lourdes (30 secondes)
app.use((req, res, next) => {
  req.setTimeout(30000);
  res.setTimeout(30000);
  next();
});

// Injecter Prisma dans req (PostgreSQL obligatoire)
app.use(injectPrisma);

// Servir les fichiers statiques avec CORS pour les images
app.use('/uploads', cors({
  origin: ['http://localhost:3000', 'http://localhost', 'https://church-frontend-51m6.onrender.com', 'https://church-front-lilac.vercel.app', 'https://multitudeszno.vercel.app', 'https://web-production-f5a55.up.railway.app'],
  credentials: false
}), express.static(path.join(__dirname, 'uploads')));

// Servir sp√©cifiquement les fichiers de t√©moignages
app.use('/uploads/testimonies', cors({
  origin: ['http://localhost:3000', 'http://localhost', 'https://church-frontend-51m6.onrender.com', 'https://church-front-lilac.vercel.app', 'https://multitudeszno.vercel.app', 'https://web-production-f5a55.up.railway.app'],
  credentials: false
}), express.static(path.join(__dirname, 'uploads/testimonies')));

// Routes publiques (AVANT le rate limiting)
app.get('/api/health', (req, res) => {
  res.json({
    success: true,
    message: '‚úÖ Serveur Church op√©rationnel',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    version: process.version
  });
});

// Endpoint de sant√© simple pour Railway
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok' });
});

// Endpoint de sant√© avec base de donn√©es (pour monitoring avanc√©)
app.get('/api/health/db', async (req, res) => {
  try {
    await prisma.$connect();
    res.json({
      success: true,
      message: '‚úÖ Serveur Church PostgreSQL op√©rationnel',
      database: 'PostgreSQL + Prisma',
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || 'development'
    });
  } catch (error) {
    logger.error('Erreur de connexion PostgreSQL:', error);
    res.status(500).json({
      success: false,
      message: '‚ùå Erreur de connexion PostgreSQL',
      error: process.env.NODE_ENV === 'production' ? 'Erreur serveur' : error.message
    });
  }
});

// Route de statistiques du cache (pour monitoring)
app.get('/api/cache/stats', (req, res) => {
  try {
    const cache = require('./utils/cache');
    const stats = cache.getStats();

    res.json({
      success: true,
      message: 'üìä Statistiques du cache',
      data: {
        ...stats,
        // Informations syst√®me masqu√©es en production
        uptime: process.env.NODE_ENV === 'production' ? 'Masqu√©' : process.uptime(),
        memory: process.env.NODE_ENV === 'production' ? 'Masqu√©' : process.memoryUsage(),
        cpu: process.env.NODE_ENV === 'production' ? 'Masqu√©' : process.cpuUsage(),
        workers: process.env.NODE_ENV === 'production' ? 'Masqu√©' : (require('cluster').isMaster ? require('os').cpus().length : 'worker')
      }
    });
  } catch (error) {
    logger.error('Erreur lors de la r√©cup√©ration des stats du cache:', error);
    res.status(500).json({
      success: false,
      message: '‚ùå Erreur lors de la r√©cup√©ration des statistiques'
    });
  }
});

// MAINTENANT appliquer le rate limiting APR√àS les routes publiques
app.use('/api/', limiter);

// Rate limiting sp√©cial pour l'authentification
app.use('/api/auth', authLimiter);

// Endpoint de sant√©
app.get('/api/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    redis: redisService ? redisService.isConnected : false,
    metrics: metricsService ? 'available' : 'unavailable'
  });
});

// Routes (le middleware protect est appliqu√© dans chaque route)
try {
  app.use('/api', require('./routes'));
  logger.startup('‚úÖ Routes principales charg√©es');
} catch (error) {
  logger.error('‚ùå Erreur lors du chargement des routes principales:', error);
}

// Route d'urgence pour cr√©er un super admin (sans authentification)
try {
  app.use('/api/emergency', require('./routes/emergency'));
  logger.startup('‚úÖ Route emergency charg√©e');
} catch (error) {
  logger.error('‚ùå Erreur lors du chargement de la route emergency:', error);
}

// Routes email (avec authentification)
try {
  app.use('/api/email', require('./routes/email'));
  logger.startup('‚úÖ Route email charg√©e');
} catch (error) {
  logger.error('‚ùå Erreur lors du chargement de la route email:', error);
}

// Routes pr√©f√©rences (avec authentification)
try {
  app.use('/api/preferences', require('./routes/preferences'));
  logger.startup('‚úÖ Route preferences charg√©e');
} catch (error) {
  logger.error('‚ùå Erreur lors du chargement de la route preferences:', error);
}

// === LOGGING PRISMA APR√àS AUTHENTIFICATION ===
app.use(prismaLogger);                    // Logging d√©taill√© des op√©rations Prisma (apr√®s auth)

// Error handling middleware avec logging complet
app.use(errorLogger);

app.use((err, req, res, next) => {
  // Logger l'erreur compl√®te c√¥t√© serveur
  logger.error('Erreur serveur:', {
    message: err.message,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });

  // Gestion sp√©cifique des erreurs CORS
  if (err.message === 'Not allowed by CORS') {
    return res.status(403).json({
      success: false,
      error: 'Origine non autoris√©e par CORS'
    });
  }

  // Ne JAMAIS exposer les d√©tails d'erreur en production
  const errorMessage = process.env.NODE_ENV === 'production'
    ? 'Une erreur interne s\'est produite. Veuillez r√©essayer plus tard.'
    : `Erreur: ${err.message}`;

  // Masquer les informations sensibles
  const sanitizedError = {
    success: false,
    error: errorMessage,
    // En d√©veloppement uniquement
    ...(process.env.NODE_ENV !== 'production' && {
      timestamp: new Date().toISOString(),
      path: req.originalUrl
    })
  };

  res.status(500).json(sanitizedError);
});

// Handle 404
app.use((req, res) => {
  res.status(404).json({
    success: false,
    error: 'Route non trouv√©e '
  });
});

const PORT = process.env.PORT || 5001;

// Cr√©er le serveur HTTP
const server = http.createServer(app);

// Initialiser Socket.IO
socketService.initialize(server);

// D√©marrer le serveur avec gestion d'erreur
try {
  server.listen(PORT, () => {
    logger.startup(`üöÄ Serveur Church PostgreSQL d√©marr√© sur le port ${PORT}`);
    logger.startup('üóÑÔ∏è Base de donn√©es: PostgreSQL + Prisma');
    logger.startup('üîå Socket.IO activ√© pour la messagerie en temps r√©el');
    logger.startup(`üåê URL: http://localhost:${PORT}`);
    logger.startup(`üîí CORS activ√© pour: ${corsOptions.origin}`);
  });

  server.on('error', (err) => {
    logger.error('‚ùå Erreur du serveur:', err);
    process.exit(1);
  });
} catch (error) {
  logger.error('‚ùå Erreur lors du d√©marrage du serveur:', error);
  process.exit(1);
}

// Gestion de la fermeture propre
process.on('SIGINT', async () => {
  logger.info('üõë Arr√™t du serveur...');
  await prisma.$disconnect();
  process.exit(0);
});

process.on('SIGTERM', async () => {
  logger.info('üõë Arr√™t du serveur...');
  await prisma.$disconnect();
  process.exit(0);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (err) => {
  logger.error('UNHANDLED REJECTION! Shutting down...', { name: err.name, message: err.message });
  process.exit(1);
});

